////
This guide is maintained in the main Quarkus repository
and pull requests should be submitted there:
https://github.com/quarkusio/quarkus/tree/main/docs/src/main/asciidoc
////
= Using Keycloak Admin Client

include::./attributes.adoc[]

The Quarkus Keycloak Admin Client and its reactive twin facilitate running the Keycloak Admin Client in a native mode.
This guide demonstrates how you can leverage the xref:cdi-reference.adoc[Quarkus ArC] and inject the admin client to your Quarkus application.
To learn more about the Keycloak Admin Client, please refer to its https://www.keycloak.org/docs/latest/server_development/#example-using-java[reference guide].

== Prerequisites

:prerequisites-docker:
include::{includes}/prerequisites.adoc[]
* https://www.keycloak.org/docs/latest/server_installation/index.html[Keycloak]

== Creating the Project

First, we need a new project.
Create a new project with the following command:

:create-app-artifact-id: security-keycloak-admin-client
:create-app-extensions: keycloak-admin-client-reactive,resteasy-reactive-jackson
include::{includes}/devtools/create-app.adoc[]

This command generates a project which imports the `keycloak-admin-client-reactive` and `resteasy-reactive-jackson` extensions.

If you already have your Quarkus project configured, you can add the `keycloak-admin-client-reactive` and `resteasy-reactive-jackson` extensions
to your project by running the following command in your project base directory:

:add-extension-extensions: keycloak-admin-client-reactive,resteasy-reactive-jackson
include::{includes}/devtools/extension-add.adoc[]

This will add the following to your build file:

[source,xml,role="primary asciidoc-tabs-target-sync-cli asciidoc-tabs-target-sync-maven"]
.pom.xml
----
<dependency>
    <groupId>io.quarkus</groupId>
    <artifactId>quarkus-keycloak-admin-client-reactive</artifactId>
</dependency>
<dependency>
    <groupId>io.quarkus</groupId>
    <artifactId>quarkus-resteasy-reactive-jackson</artifactId>
</dependency>
----

[source,gradle,role="secondary asciidoc-tabs-target-sync-gradle"]
.build.gradle
----
implementation("io.quarkus:quarkus-keycloak-admin-client-reactive")
implementation("io.quarkus:quarkus-resteasy-reactive-jackson")
----

We also are going to need a simple resource with a `Keycloak` injected as request scoped CDI bean.

[source,java]
----
package org.acme.keycloak.admin.client;

import io.quarkus.security.Authenticated;
import org.keycloak.admin.client.Keycloak;
import org.keycloak.representations.idm.RoleRepresentation;

import javax.inject.Inject;
import javax.ws.rs.GET;
import javax.ws.rs.Path;
import java.util.List;

@Authenticated
@Path("/api/admin")
public class RolesResource {

        @Inject
        Keycloak keycloak;

        @GET
        @Path("/roles")
        public List<RoleRepresentation> getRoles() {
            return keycloak.realm("quarkus").roles().list();
        }

}
----

Now, you can produce the `Keycloak` bean yourself, or you can instruct Quarkus to produce `Keycloak` bean.

NOTE: If you produce the bean yourself, please remember that `org.keycloak.admin.client.Keycloak` implements `AutoCloseable` and it's important to avoid resource exhaustion and related exceptions. If you configure your beans as explained below, Quarkus will do it for you.

The Keycloak admin client needs access token as its Admin REST API requires authorization.
If you already have a way to get access token, let's call it `CustomTokenService`, all you need to do is to provide bean that implements `KeycloakAdminClientAuthorizationProvider`, as shown below.

[source,java]
----
@ApplicationScoped <1>
public class CustomAuthZProvider implements KeycloakAdminClientAuthorizationProvider { <2>

    @Inject
    CustomTokenService customTokenService;

    @Override
    public String getAuthorization() {
        return customTokenService.get();
    }

}
----
<1> The provider must be a CDI bean.
<2> Make sure it implements `KeycloakAdminClientAuthorizationProvider`.

It's also important to tell Quarkus to use the provider and configure the Keycloak server URL.

[source,properties]
----
quarkus.keycloak.admin-client."client-name".realm=quarkus <1>
quarkus.keycloak.admin-client."client-name".auth-method=AUTH_TOKEN <2> <3>
quarkus.keycloak.admin-client."client-name".authorization-provider=org.acme.keycloak.admin.client.CustomAuthZProvider <4>
quarkus.keycloak.admin-client."client-name".server-url=http://localhost:8181 <5>
----
<1> Use `quarkus` realm.
<2> Create bean named `client-name`.
<3> Tell Quarkus that you will provide the token yourself.
<4> Matches the fully qualified name of a provider class.
<5> The Keycloak server URL.

Alternatively, if you exchange a user's credentials for an access token, forget about the authorization provider and set properties like this:

[source,properties]
----
quarkus.keycloak.admin-client."client-name".realm=quarkus
quarkus.keycloak.admin-client."client-name".server-url=http://localhost:8181
quarkus.keycloak.admin-client."client-name".auth-method=PASSWORD <1>
quarkus.keycloak.admin-client."client-name".username=doctor
quarkus.keycloak.admin-client."client-name".password=who
quarkus.keycloak.admin-client."client-name".client-id=quarkus-app
----
<1> Use `password` grant type.

An example using the `client-credentials` grant type needs only a minor adjustments:

[source,properties]
----
quarkus.keycloak.admin-client."client-name".realm=quarkus
quarkus.keycloak.admin-client."client-name".server-url=http://localhost:8181
quarkus.keycloak.admin-client."client-name".auth-method=CLIENT_CREDENTIALS <1>
quarkus.keycloak.admin-client."client-name".client-id=quarkus-app
quarkus.keycloak.admin-client."client-name".client-secret=secret
----
<1> Use `client_credentials` grant type.

It's possible to create multiple clients this way, just remember you will need to designate injection points with `@Named`.

[source,java]
----
package org.acme.keycloak.admin.client;

import org.keycloak.admin.client.Keycloak;

import javax.inject.Inject;
import javax.inject.Named;
import javax.ws.rs.Path;

@Authenticated
@Path("/api/admin")
public class RolesResource {

        @Named("client-name")
        @Inject
        Keycloak keycloak;

        @Named("client-name2")
        @Inject
        Keycloak keycloak2;

        ...
}
----

== Working together with the Quarkus OpenID Connect and a Keycloak server

There is even simpler way to set up your admin client as long as you are using `quarkus-oidc` extension.
Quarkus OIDC provides its own implementation of `KeycloakAdminClientAuthorizationProvider` that takes access token from a request and supplies it to the admin client.
Example configuration for the Quarkus OIDC provider:

[source,properties]
----
quarkus.keycloak.admin-client."client-name".realm=quarkus
quarkus.keycloak.admin-client."client-name".auth-method=AUTH_TOKEN
----

NOTE: By default, the Quarkus extracts the URL from `quarkus.oidc.auth-server-url` property.

== Develop with Dev Services for Keycloak

Similarly to well-known users `alice` and `bob`, Quarkus configures `admin` client when there are no user-defined clients.
For more information, please see configuration property `quarkus.keycloak.admin-client.devservices.enabled`.

More complex scenarios will probably require you to define a Keycloak realm file, however you can also let the Dev Services for Keycloak create realm for you.
Here is how you can create realm `quarkus` with user `duke` that has rights to view realm roles and users:

[source,properties]
----
%dev.quarkus.keycloak.devservices.users.duke=dukePassword
%dev.quarkus.keycloak.devservices.roles.duke=admin,user
%dev.quarkus.keycloak.devservices.realm-name=quarkus
%dev.quarkus.keycloak.devservices.create-realm=true
%dev.quarkus.keycloak.devservices.client-roles.duke.realm-management=view-roles,view-users
# removes default client scope 'jwt-microprofile'
%dev.quarkus.keycloak.devservices.default-client-scopes=

# password grant type
quarkus.keycloak.admin-client."duke".username=duke
quarkus.keycloak.admin-client."duke".password=dukePassword
quarkus.keycloak.admin-client."duke".client-id=quarkus-app
quarkus.keycloak.admin-client."duke".client-secret=secret
quarkus.keycloak.admin-client."duke".auth-method=PASSWORD
quarkus.keycloak.admin-client."duke".realm=quarkus
----

== Customize RestEasy Client

The Keycloak admin client uses a RestEasy Client that is fit for most scenarios, but also provides customization mechanism to, let say, add your own Keystore or disable hostname verification.

[source,java]
----
@ApplicationScoped
public class RegisterSecuredClientProvider {

    void onStart(@Observes StartupEvent ev) { <1>
        Keycloak.setClientProvider(new ResteasyReactiveClientProvider() { <2>

            @Override
            protected ClientBuilderImpl newClientBuilder() {
                return (ClientBuilderImpl) super.newClientBuilder()
                        .trustStore(myTruststore)
                        .keyStore(myKeystore);
            }
        });
    }

}
----
<1> A client provider must be set before Keycloak instance is created.
<2> Your RestEasy client should be set to `org.keycloak.admin.client.Keycloak.setClientProvider`, here we take advantage of standard `ResteasyReactiveClientProvider`.

[[arc-configuration-reference]]
== Quarkus Keycloak Admin Client Configuration Reference

include::{generated-dir}/config/quarkus-keycloak-admin-client.adoc[leveloffset=+1, opts=optional]

== References

* https://www.keycloak.org/documentation.html[Keycloak Documentation]
* xref:security-keycloak-authorization.adoc[Keycloak Authorization extension]
* xref:security-openid-connect-web-authentication.adoc[Using OpenID Connect to Protect Web Application]
* xref:security.adoc[Quarkus Security]
* xref:security-openid-connect.adoc[Using OpenID Connect to Protect Service Applications]